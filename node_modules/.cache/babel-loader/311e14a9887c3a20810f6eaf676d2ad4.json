{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PreviousableTwitterPaginator = exports.TwitterPaginator = void 0;\n/** TwitterPaginator: able to get consume data from initial request, then fetch next data sequentially. */\n\nclass TwitterPaginator {\n  // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\n  constructor(_ref) {\n    let {\n      realData,\n      rateLimit,\n      instance,\n      queryParams,\n      sharedParams\n    } = _ref;\n    this._maxResultsWhenFetchLast = 100;\n    this._realData = realData;\n    this._rateLimit = rateLimit;\n    this._instance = instance;\n    this._queryParams = queryParams;\n    this._sharedParams = sharedParams;\n  }\n\n  get _isRateLimitOk() {\n    const resetDate = this._rateLimit.reset * 1000;\n\n    if (resetDate < Date.now()) {\n      return true;\n    }\n\n    return this._rateLimit.remaining > 0;\n  }\n\n  makeRequest(queryParams) {\n    return this._instance.get(this.getEndpoint(), queryParams, {\n      fullResponse: true,\n      params: this._sharedParams\n    });\n  }\n\n  makeNewInstanceFromResult(result, queryParams) {\n    // Construct a subclass\n    return new this.constructor({\n      realData: result.data,\n      rateLimit: result.rateLimit,\n      instance: this._instance,\n      queryParams,\n      sharedParams: this._sharedParams\n    });\n  }\n\n  getEndpoint() {\n    return this._endpoint;\n  }\n\n  injectQueryParams(maxResults) {\n    return { ...(maxResults ? {\n        max_results: maxResults\n      } : {}),\n      ...this._queryParams\n    };\n  }\n  /* ---------------------- */\n\n  /* Real paginator methods */\n\n  /* ---------------------- */\n\n  /**\n   * Next page.\n   */\n\n\n  async next(maxResults) {\n    const queryParams = this.getNextQueryParams(maxResults);\n    const result = await this.makeRequest(queryParams);\n    return this.makeNewInstanceFromResult(result, queryParams);\n  }\n  /**\n   * Next page, but store it in current instance.\n   */\n\n\n  async fetchNext(maxResults) {\n    const queryParams = this.getNextQueryParams(maxResults);\n    const result = await this.makeRequest(queryParams); // Await in case of async sub-methods\n\n    await this.refreshInstanceFromResult(result, true);\n    return this;\n  }\n  /**\n   * Fetch up to {count} items after current page,\n   * as long as rate limit is not hit and Twitter has some results\n   */\n\n\n  async fetchLast() {\n    let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;\n    let queryParams = this.getNextQueryParams(this._maxResultsWhenFetchLast);\n    let resultCount = 0; // Break at rate limit limit\n\n    while (resultCount < count && this._isRateLimitOk) {\n      const response = await this.makeRequest(queryParams);\n      await this.refreshInstanceFromResult(response, true);\n      resultCount += this.getPageLengthFromRequest(response);\n\n      if (this.isFetchLastOver(response)) {\n        break;\n      }\n\n      queryParams = this.getNextQueryParams(this._maxResultsWhenFetchLast);\n    }\n\n    return this;\n  }\n\n  get rateLimit() {\n    return { ...this._rateLimit\n    };\n  }\n  /** Get raw data returned by Twitter API. */\n\n\n  get data() {\n    return this._realData;\n  }\n\n  get done() {\n    return !this.canFetchNextPage(this._realData);\n  }\n  /**\n   * Iterate over currently fetched items.\n   */\n\n\n  *[Symbol.iterator]() {\n    yield* this.getItemArray();\n  }\n  /**\n   * Iterate over items \"undefinitely\" (until rate limit is hit / they're no more tweets available)\n   */\n\n\n  async *[Symbol.asyncIterator]() {\n    yield* this.getItemArray(); // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n    let paginator = this;\n    let canFetchNextPage = this.canFetchNextPage(this._realData);\n\n    while (canFetchNextPage && this._isRateLimitOk && paginator.getItemArray().length > 0) {\n      const next = await paginator.next(this._maxResultsWhenFetchLast);\n      canFetchNextPage = this.canFetchNextPage(next._realData);\n      this._rateLimit = next._rateLimit;\n      const items = next.getItemArray();\n      yield* items;\n      paginator = next;\n    }\n  }\n\n}\n\nexports.TwitterPaginator = TwitterPaginator;\n/** PreviousableTwitterPaginator: a TwitterPaginator able to get consume data from both side, next and previous. */\n\nclass PreviousableTwitterPaginator extends TwitterPaginator {\n  /**\n   * Previous page (new tweets)\n   */\n  async previous(maxResults) {\n    const queryParams = this.getPreviousQueryParams(maxResults);\n    const result = await this.makeRequest(queryParams);\n    return this.makeNewInstanceFromResult(result, queryParams);\n  }\n  /**\n   * Previous page, but in current instance.\n   */\n\n\n  async fetchPrevious(maxResults) {\n    const queryParams = this.getPreviousQueryParams(maxResults);\n    const result = await this.makeRequest(queryParams);\n    await this.refreshInstanceFromResult(result, false);\n    return this;\n  }\n\n}\n\nexports.PreviousableTwitterPaginator = PreviousableTwitterPaginator;\nexports.default = TwitterPaginator;","map":{"version":3,"sources":["/Users/tarungunampalli/Documents/twitter-oauth/node_modules/twitter-api-v2/dist/paginators/TwitterPaginator.js"],"names":["Object","defineProperty","exports","value","PreviousableTwitterPaginator","TwitterPaginator","constructor","realData","rateLimit","instance","queryParams","sharedParams","_maxResultsWhenFetchLast","_realData","_rateLimit","_instance","_queryParams","_sharedParams","_isRateLimitOk","resetDate","reset","Date","now","remaining","makeRequest","get","getEndpoint","fullResponse","params","makeNewInstanceFromResult","result","data","_endpoint","injectQueryParams","maxResults","max_results","next","getNextQueryParams","fetchNext","refreshInstanceFromResult","fetchLast","count","Infinity","resultCount","response","getPageLengthFromRequest","isFetchLastOver","done","canFetchNextPage","Symbol","iterator","getItemArray","asyncIterator","paginator","length","items","previous","getPreviousQueryParams","fetchPrevious","default"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PreviousableTwitterPaginator = exports.TwitterPaginator = void 0;\n/** TwitterPaginator: able to get consume data from initial request, then fetch next data sequentially. */\nclass TwitterPaginator {\n    // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\n    constructor({ realData, rateLimit, instance, queryParams, sharedParams }) {\n        this._maxResultsWhenFetchLast = 100;\n        this._realData = realData;\n        this._rateLimit = rateLimit;\n        this._instance = instance;\n        this._queryParams = queryParams;\n        this._sharedParams = sharedParams;\n    }\n    get _isRateLimitOk() {\n        const resetDate = this._rateLimit.reset * 1000;\n        if (resetDate < Date.now()) {\n            return true;\n        }\n        return this._rateLimit.remaining > 0;\n    }\n    makeRequest(queryParams) {\n        return this._instance.get(this.getEndpoint(), queryParams, { fullResponse: true, params: this._sharedParams });\n    }\n    makeNewInstanceFromResult(result, queryParams) {\n        // Construct a subclass\n        return new this.constructor({\n            realData: result.data,\n            rateLimit: result.rateLimit,\n            instance: this._instance,\n            queryParams,\n            sharedParams: this._sharedParams,\n        });\n    }\n    getEndpoint() {\n        return this._endpoint;\n    }\n    injectQueryParams(maxResults) {\n        return {\n            ...(maxResults ? { max_results: maxResults } : {}),\n            ...this._queryParams,\n        };\n    }\n    /* ---------------------- */\n    /* Real paginator methods */\n    /* ---------------------- */\n    /**\n     * Next page.\n     */\n    async next(maxResults) {\n        const queryParams = this.getNextQueryParams(maxResults);\n        const result = await this.makeRequest(queryParams);\n        return this.makeNewInstanceFromResult(result, queryParams);\n    }\n    /**\n     * Next page, but store it in current instance.\n     */\n    async fetchNext(maxResults) {\n        const queryParams = this.getNextQueryParams(maxResults);\n        const result = await this.makeRequest(queryParams);\n        // Await in case of async sub-methods\n        await this.refreshInstanceFromResult(result, true);\n        return this;\n    }\n    /**\n     * Fetch up to {count} items after current page,\n     * as long as rate limit is not hit and Twitter has some results\n     */\n    async fetchLast(count = Infinity) {\n        let queryParams = this.getNextQueryParams(this._maxResultsWhenFetchLast);\n        let resultCount = 0;\n        // Break at rate limit limit\n        while (resultCount < count && this._isRateLimitOk) {\n            const response = await this.makeRequest(queryParams);\n            await this.refreshInstanceFromResult(response, true);\n            resultCount += this.getPageLengthFromRequest(response);\n            if (this.isFetchLastOver(response)) {\n                break;\n            }\n            queryParams = this.getNextQueryParams(this._maxResultsWhenFetchLast);\n        }\n        return this;\n    }\n    get rateLimit() {\n        return { ...this._rateLimit };\n    }\n    /** Get raw data returned by Twitter API. */\n    get data() {\n        return this._realData;\n    }\n    get done() {\n        return !this.canFetchNextPage(this._realData);\n    }\n    /**\n     * Iterate over currently fetched items.\n     */\n    *[Symbol.iterator]() {\n        yield* this.getItemArray();\n    }\n    /**\n     * Iterate over items \"undefinitely\" (until rate limit is hit / they're no more tweets available)\n     */\n    async *[Symbol.asyncIterator]() {\n        yield* this.getItemArray();\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let paginator = this;\n        let canFetchNextPage = this.canFetchNextPage(this._realData);\n        while (canFetchNextPage && this._isRateLimitOk && paginator.getItemArray().length > 0) {\n            const next = await paginator.next(this._maxResultsWhenFetchLast);\n            canFetchNextPage = this.canFetchNextPage(next._realData);\n            this._rateLimit = next._rateLimit;\n            const items = next.getItemArray();\n            yield* items;\n            paginator = next;\n        }\n    }\n}\nexports.TwitterPaginator = TwitterPaginator;\n/** PreviousableTwitterPaginator: a TwitterPaginator able to get consume data from both side, next and previous. */\nclass PreviousableTwitterPaginator extends TwitterPaginator {\n    /**\n     * Previous page (new tweets)\n     */\n    async previous(maxResults) {\n        const queryParams = this.getPreviousQueryParams(maxResults);\n        const result = await this.makeRequest(queryParams);\n        return this.makeNewInstanceFromResult(result, queryParams);\n    }\n    /**\n     * Previous page, but in current instance.\n     */\n    async fetchPrevious(maxResults) {\n        const queryParams = this.getPreviousQueryParams(maxResults);\n        const result = await this.makeRequest(queryParams);\n        await this.refreshInstanceFromResult(result, false);\n        return this;\n    }\n}\nexports.PreviousableTwitterPaginator = PreviousableTwitterPaginator;\nexports.default = TwitterPaginator;\n"]},"metadata":{},"sourceType":"script"}