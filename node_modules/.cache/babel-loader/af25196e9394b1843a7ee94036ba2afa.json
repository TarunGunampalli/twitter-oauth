{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TweetStreamEventCombiner = void 0;\n\nconst events_1 = require(\"events\");\n\nconst types_1 = require(\"../types\");\n\nclass TweetStreamEventCombiner extends events_1.EventEmitter {\n  constructor(stream) {\n    super();\n    this.stream = stream;\n    this.stack = [];\n    this.onStreamData = this.onStreamData.bind(this);\n    this.onStreamError = this.onStreamError.bind(this);\n    this.onceNewEvent = this.once.bind(this, 'event'); // Init events from stream\n\n    stream.on(types_1.ETwitterStreamEvent.Data, this.onStreamData); // Ignore reconnect errors: Don't close event combiner until connection error/closed\n\n    stream.on(types_1.ETwitterStreamEvent.ConnectionError, this.onStreamError);\n    stream.on(types_1.ETwitterStreamEvent.TweetParseError, this.onStreamError);\n    stream.on(types_1.ETwitterStreamEvent.ConnectionClosed, this.onStreamError);\n  }\n  /** Returns a new `Promise` that will `resolve` on next event (`data` or any sort of error). */\n\n\n  nextEvent() {\n    return new Promise(this.onceNewEvent);\n  }\n  /** Returns `true` if there's something in the stack. */\n\n\n  hasStack() {\n    return this.stack.length > 0;\n  }\n  /** Returns stacked data events, and clean the stack. */\n\n\n  popStack() {\n    const stack = this.stack;\n    this.stack = [];\n    return stack;\n  }\n  /** Cleanup all the listeners attached on stream. */\n\n\n  destroy() {\n    this.removeAllListeners();\n    this.stream.off(types_1.ETwitterStreamEvent.Data, this.onStreamData);\n    this.stream.off(types_1.ETwitterStreamEvent.ConnectionError, this.onStreamError);\n    this.stream.off(types_1.ETwitterStreamEvent.TweetParseError, this.onStreamError);\n    this.stream.off(types_1.ETwitterStreamEvent.ConnectionClosed, this.onStreamError);\n  }\n\n  emitEvent(type, payload) {\n    this.emit('event', {\n      type,\n      payload\n    });\n  }\n\n  onStreamError(payload) {\n    this.emitEvent('error', payload);\n  }\n\n  onStreamData(payload) {\n    this.stack.push(payload);\n    this.emitEvent('data', payload);\n  }\n\n}\n\nexports.TweetStreamEventCombiner = TweetStreamEventCombiner;\nexports.default = TweetStreamEventCombiner;","map":{"version":3,"sources":["/Users/tarungunampalli/Documents/twitter-oauth/node_modules/twitter-api-v2/dist/stream/TweetStreamEventCombiner.js"],"names":["Object","defineProperty","exports","value","TweetStreamEventCombiner","events_1","require","types_1","EventEmitter","constructor","stream","stack","onStreamData","bind","onStreamError","onceNewEvent","once","on","ETwitterStreamEvent","Data","ConnectionError","TweetParseError","ConnectionClosed","nextEvent","Promise","hasStack","length","popStack","destroy","removeAllListeners","off","emitEvent","type","payload","emit","push","default"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,wBAAR,GAAmC,KAAK,CAAxC;;AACA,MAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAD,CAAxB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMF,wBAAN,SAAuCC,QAAQ,CAACG,YAAhD,CAA6D;AACzDC,EAAAA,WAAW,CAACC,MAAD,EAAS;AAChB;AACA,SAAKA,MAAL,GAAcA,MAAd;AACA,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKC,YAAL,GAAoB,KAAKA,YAAL,CAAkBC,IAAlB,CAAuB,IAAvB,CAApB;AACA,SAAKC,aAAL,GAAqB,KAAKA,aAAL,CAAmBD,IAAnB,CAAwB,IAAxB,CAArB;AACA,SAAKE,YAAL,GAAoB,KAAKC,IAAL,CAAUH,IAAV,CAAe,IAAf,EAAqB,OAArB,CAApB,CANgB,CAOhB;;AACAH,IAAAA,MAAM,CAACO,EAAP,CAAUV,OAAO,CAACW,mBAAR,CAA4BC,IAAtC,EAA4C,KAAKP,YAAjD,EARgB,CAShB;;AACAF,IAAAA,MAAM,CAACO,EAAP,CAAUV,OAAO,CAACW,mBAAR,CAA4BE,eAAtC,EAAuD,KAAKN,aAA5D;AACAJ,IAAAA,MAAM,CAACO,EAAP,CAAUV,OAAO,CAACW,mBAAR,CAA4BG,eAAtC,EAAuD,KAAKP,aAA5D;AACAJ,IAAAA,MAAM,CAACO,EAAP,CAAUV,OAAO,CAACW,mBAAR,CAA4BI,gBAAtC,EAAwD,KAAKR,aAA7D;AACH;AACD;;;AACAS,EAAAA,SAAS,GAAG;AACR,WAAO,IAAIC,OAAJ,CAAY,KAAKT,YAAjB,CAAP;AACH;AACD;;;AACAU,EAAAA,QAAQ,GAAG;AACP,WAAO,KAAKd,KAAL,CAAWe,MAAX,GAAoB,CAA3B;AACH;AACD;;;AACAC,EAAAA,QAAQ,GAAG;AACP,UAAMhB,KAAK,GAAG,KAAKA,KAAnB;AACA,SAAKA,KAAL,GAAa,EAAb;AACA,WAAOA,KAAP;AACH;AACD;;;AACAiB,EAAAA,OAAO,GAAG;AACN,SAAKC,kBAAL;AACA,SAAKnB,MAAL,CAAYoB,GAAZ,CAAgBvB,OAAO,CAACW,mBAAR,CAA4BC,IAA5C,EAAkD,KAAKP,YAAvD;AACA,SAAKF,MAAL,CAAYoB,GAAZ,CAAgBvB,OAAO,CAACW,mBAAR,CAA4BE,eAA5C,EAA6D,KAAKN,aAAlE;AACA,SAAKJ,MAAL,CAAYoB,GAAZ,CAAgBvB,OAAO,CAACW,mBAAR,CAA4BG,eAA5C,EAA6D,KAAKP,aAAlE;AACA,SAAKJ,MAAL,CAAYoB,GAAZ,CAAgBvB,OAAO,CAACW,mBAAR,CAA4BI,gBAA5C,EAA8D,KAAKR,aAAnE;AACH;;AACDiB,EAAAA,SAAS,CAACC,IAAD,EAAOC,OAAP,EAAgB;AACrB,SAAKC,IAAL,CAAU,OAAV,EAAmB;AAAEF,MAAAA,IAAF;AAAQC,MAAAA;AAAR,KAAnB;AACH;;AACDnB,EAAAA,aAAa,CAACmB,OAAD,EAAU;AACnB,SAAKF,SAAL,CAAe,OAAf,EAAwBE,OAAxB;AACH;;AACDrB,EAAAA,YAAY,CAACqB,OAAD,EAAU;AAClB,SAAKtB,KAAL,CAAWwB,IAAX,CAAgBF,OAAhB;AACA,SAAKF,SAAL,CAAe,MAAf,EAAuBE,OAAvB;AACH;;AA9CwD;;AAgD7D/B,OAAO,CAACE,wBAAR,GAAmCA,wBAAnC;AACAF,OAAO,CAACkC,OAAR,GAAkBhC,wBAAlB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TweetStreamEventCombiner = void 0;\nconst events_1 = require(\"events\");\nconst types_1 = require(\"../types\");\nclass TweetStreamEventCombiner extends events_1.EventEmitter {\n    constructor(stream) {\n        super();\n        this.stream = stream;\n        this.stack = [];\n        this.onStreamData = this.onStreamData.bind(this);\n        this.onStreamError = this.onStreamError.bind(this);\n        this.onceNewEvent = this.once.bind(this, 'event');\n        // Init events from stream\n        stream.on(types_1.ETwitterStreamEvent.Data, this.onStreamData);\n        // Ignore reconnect errors: Don't close event combiner until connection error/closed\n        stream.on(types_1.ETwitterStreamEvent.ConnectionError, this.onStreamError);\n        stream.on(types_1.ETwitterStreamEvent.TweetParseError, this.onStreamError);\n        stream.on(types_1.ETwitterStreamEvent.ConnectionClosed, this.onStreamError);\n    }\n    /** Returns a new `Promise` that will `resolve` on next event (`data` or any sort of error). */\n    nextEvent() {\n        return new Promise(this.onceNewEvent);\n    }\n    /** Returns `true` if there's something in the stack. */\n    hasStack() {\n        return this.stack.length > 0;\n    }\n    /** Returns stacked data events, and clean the stack. */\n    popStack() {\n        const stack = this.stack;\n        this.stack = [];\n        return stack;\n    }\n    /** Cleanup all the listeners attached on stream. */\n    destroy() {\n        this.removeAllListeners();\n        this.stream.off(types_1.ETwitterStreamEvent.Data, this.onStreamData);\n        this.stream.off(types_1.ETwitterStreamEvent.ConnectionError, this.onStreamError);\n        this.stream.off(types_1.ETwitterStreamEvent.TweetParseError, this.onStreamError);\n        this.stream.off(types_1.ETwitterStreamEvent.ConnectionClosed, this.onStreamError);\n    }\n    emitEvent(type, payload) {\n        this.emit('event', { type, payload });\n    }\n    onStreamError(payload) {\n        this.emitEvent('error', payload);\n    }\n    onStreamData(payload) {\n        this.stack.push(payload);\n        this.emitEvent('data', payload);\n    }\n}\nexports.TweetStreamEventCombiner = TweetStreamEventCombiner;\nexports.default = TweetStreamEventCombiner;\n"]},"metadata":{},"sourceType":"script"}